# NetGuardian - Мониторинг и анализ сетевого трафика

## Содержание
- [Обзор проекта](#обзор-проекта)
- [Текущий статус реализации](#текущий-статус-реализации)
- [Функциональность](#функциональность)
- [Технические детали](#технические-детали)
- [Установка и сборка](#установка-и-сборка)
- [Использование](#использование)
- [Архитектура и компоненты](#архитектура-и-компоненты)
- [Тестирование (Ручное)](#Ручное-тестирование)
- [Тестирование (Автотесты через doctest)](#Автоматические-тесты)
- [Установка и сборка](#Установка-и-сборка)
## Обзор проекта

NetworkTrafficMonitor - это приложение для мониторинга состояния локальной сети, разработанное на C++. Оно предоставляет инструменты для обнаружения подключенных устройств, анализа сетевого трафика и выявления потенциальных угроз с использованием технологий искусственного интеллекта.

### Основные возможности
- Сканирование сети и обнаружение активных устройств
- Отображение списка устройств с их параметрами (IP, MAC, статус, задержка)
- Проверка доступности устройств (Ping)
- Логирование событий (подключение/отключение устройств)
- Анализ сетевого трафика в реальном времени
- Сохранение данных в SQLite или CSV
- ИИ-анализ трафика для обнаружения аномалий

## Текущий статус реализации

### Реализовано ✅
1. **Захват сетевого трафика**
   - Интеграция с Npcap/PcapPlusPlus
   - Поддержка различных сетевых интерфейсов
   - Фильтрация пакетов

2. **Пользовательский интерфейс**
   - Отображение списка сетевых интерфейсов
   - Таблица пакетов с детальной информацией
   - Статистика по протоколам
   - Фильтрация и поиск
   - Цветовая индикация протоколов

3. **Логирование**
   - Сохранение в SQLite
   - Экспорт в CSV
   - Асинхронное логирование

4. **Базовый ИИ-анализ**
   - Интеграция с ONNX Runtime
   - Базовая модель анализа трафика
   - Отдельная панель для подозрительного трафика

## Технические детали

### Используемые технологии

1. **C++17**
   - Выбор обусловлен производительностью и низкоуровневым контролем
   - Прямой доступ к сетевым операциям
   - Минимальные накладные расходы
   - Потенциальная кроссплатформенность

2. **wxWidgets**
   - Кроссплатформенный GUI-фреймворк
   - Поддержка тем и стилизации
   - Богатый набор готовых виджетов
   - Меньший размер дистрибутива по сравнению с Qt

3. **Npcap + PcapPlusPlus**
   - Npcap: современный драйвер для Windows 10/11
   - PcapPlusPlus: C++ обертка с удобным API
   - Поддержка многопоточности
   - Расширенные возможности фильтрации

4. **Система сборки**
   - CMake для кроссплатформенной сборки
   - Conan для управления зависимостями
   - Поддержка различных конфигураций сборки

5. **Оптимизация производительности**
   - Буферизация данных для снижения нагрузки
   - Асинхронное логирование
   - Оптимизация обновлений UI

## Архитектура и компоненты

### Основные классы и их функции

1. **MainFrame** (`main_frame.h/cpp`)
   - Основное окно приложения
   - Управление UI-элементами
   - Обработка событий
   - Интеграция с ИИ-моделью
   ```cpp
   class MainFrame : public wxFrame {
       // Инициализация UI и компонентов
       void InitializeUI();
       // Обработка пакетов
       void ProcessPacketData();
       // Анализ трафика через ИИ
       void AnalyzePacketAI();
   };
   ```

2. **TrafficCapture** (`traffic_capture.h/cpp`)
   - Захват сетевого трафика
   - Управление сетевыми интерфейсами
   - Фильтрация пакетов
   ```cpp
   class TrafficCapture {
       // Инициализация захвата
       bool initialize();
       // Начало захвата
       void startCapture();
       // Остановка захвата
       void stopCapture();
   };
   ```

3. **TrafficLogger** (`traffic_logger.h/cpp`)
   - Логирование трафика
   - Сохранение в SQLite/CSV
   - Асинхронная запись
   ```cpp
   class TrafficLogger {
       // Инициализация логгера
       bool initialize();
       // Асинхронное логирование
       void asyncLogPacket();
       // Закрытие логгера
       void close();
   };
   ```
## Ручное_тестирование
Ручное тестирование необходимо для проверки пользовательского интерфейса, интеграции и сценариев, которые сложно покрыть автотестами.
### 1. Проверка запуска и интерфейса
- **Шаги:**
  1. Запустите приложение `NetworkTrafficMonitor.exe`.
  2. Убедитесь, что окно открывается, все элементы управления (кнопки, списки, поля ввода) отображаются корректно.
  3. Проверьте, что интерфейс не "заморожен" и реагирует на действия пользователя.
- **Ожидаемый результат:** Приложение запускается, интерфейс работает корректно.

### 2. Тестирование захвата трафика
- **Шаги:**
  1. Выберите сетевой интерфейс из списка.
  2. Нажмите кнопку "Start" для начала захвата.
  3. Убедитесь, что пакеты начинают отображаться в таблице, информация обновляется в реальном времени.
  4. Остановите захват кнопкой "Stop" — поток пакетов должен прекратиться.
  5. Повторно запустите захват, убедитесь, что приложение корректно работает после остановки.
- **Ожидаемый результат:** Пакеты отображаются, захват можно запускать и останавливать многократно.

### 3. Проверка фильтрации и поиска
- **Шаги:**
  1. Введите фильтр по протоколу (например, `TCP`, `UDP`, `DNS`) или IP-адресу.
  2. Убедитесь, что отображаются только соответствующие пакеты.
  3. Очистите фильтр — должны отображаться все пакеты.
- **Ожидаемый результат:** Фильтрация работает корректно.

### 4. Проверка AI-анализа
- **Шаги:**
  1. Включите опцию AI-анализа (если доступна).
  2. Проверьте, что анализ работает, результаты отображаются в отдельной таблице/гриде.
  3. Проверьте, что при отключении AI-анализа результаты скрываются.
- **Ожидаемый результат:** AI-анализ работает, результаты корректно отображаются и скрываются.

### 5. Проверка логирования
- **Шаги:**
  1. Включите логирование в файл (выберите путь для сохранения).
  2. Проверьте, что файл создаётся и содержит корректные записи о трафике.
  3. Откройте файл в текстовом редакторе и убедитесь, что структура и данные соответствуют ожидаемым.
- **Ожидаемый результат:** Лог-файл создаётся и содержит корректные данные.

### 6. Проверка обработки ошибок
- **Шаги:**
  1. Отключите сетевой интерфейс и попробуйте начать захват — приложение должно корректно обработать ошибку (например, показать сообщение).
  2. Попробуйте выбрать несуществующий путь для логирования — должна появиться ошибка.
  3. Попробуйте начать захват без выбора интерфейса — приложение должно предупредить пользователя.
- **Ожидаемый результат:** Ошибки корректно обрабатываются, пользователь информируется.

### 7. Проверка локализации и поддержки Unicode
- **Шаги:**
  1. Введите в фильтр или другие поля текст на русском языке или с использованием специальных символов.
  2. Убедитесь, что приложение корректно отображает и обрабатывает Unicode-символы.
- **Ожидаемый результат:** Приложение поддерживает Unicode и локализацию.

### 8. Проверка стабильности и производительности
- **Шаги:**
  1. Оставьте захват трафика включённым на длительное время (10-30 минут).
  2. Убедитесь, что приложение не "утекает" по памяти, не зависает и не падает.
  3. Проверьте, что интерфейс остаётся отзывчивым даже при большом количестве пакетов.
- **Ожидаемый результат:** Приложение стабильно работает длительное время.

### 9. Проверка работы с несколькими окнами
- **Шаги:**
  1. Откройте несколько экземпляров приложения (если поддерживается).
  2. Убедитесь, что каждый экземпляр работает независимо и корректно.
- **Ожидаемый результат:** Несколько окон работают параллельно без конфликтов.

### 10. Проверка корректного завершения работы
- **Шаги:**
  1. Завершите работу приложения через меню или кнопку "Закрыть".
  2. Убедитесь, что все ресурсы освобождаются, логи корректно закрываются, приложение не остаётся в процессах.
- **Ожидаемый результат:** Приложение корректно завершает работу, не оставляя "висячих" процессов.

## Автоматические тесты

В проекте реализованы автотесты с помощью библиотеки [doctest](https://github.com/doctest/doctest). Все тесты находятся в файле [`tests/unit_tests.cpp`](./tests/unit_tests.cpp).

### Описание автотестов

#### 1. ProtocolNameFromPacket - TCP variants
- **Назначение:** Проверяет определение протокола для TCP-пакетов.
- **Входные данные:** Искусственно созданные TCP-пакеты с разными портами.
- **Проверки:**
  - HTTP (порт 80) → ожидается строка `"HTTP"`
  - HTTPS (порт 443) → ожидается строка `"HTTPS"`
  - Прочие TCP (порт 1234) → ожидается строка `"TCP"`
- **Ожидаемый результат:** Для каждого случая функция возвращает корректное имя протокола.

#### 2. ProtocolNameFromPacket - UDP variants
- **Назначение:** Проверяет определение протокола для UDP-пакетов.
- **Входные данные:** Искусственно созданные UDP-пакеты с разными портами.
- **Проверки:**
  - DNS (порт 53) → ожидается строка `"DNS"`
  - Прочие UDP (порт 1234) → ожидается строка `"UDP"`
- **Ожидаемый результат:** Для каждого случая функция возвращает корректное имя протокола.

#### 3. ProtocolNameFromPacket - ARP, ICMP, IPv4, IPv6
- **Назначение:** Проверяет определение протокола для специальных и fallback-пакетов.
- **Входные данные:** Искусственно созданные пакеты ARP, ICMP, IPv4 (без TCP/UDP/ICMP), IPv6.
- **Проверки:**
  - ARP → ожидается строка `"ARP"`
  - ICMP → ожидается строка `"ICMP"`
  - IPv4 (fallback) → ожидается строка `"IPv4"`
  - IPv6 (fallback) → ожидается строка `"IPv6"`
- **Ожидаемый результат:** Для каждого случая функция возвращает корректное имя протокола.

#### 4. GetLengthIndicator - all categories
- **Назначение:** Проверяет функцию-индикатор размера пакета.
- **Входные данные:** Различные значения длины пакета.
- **Проверки:**
  - >1500 байт → ожидается строка `"Large packet"`
  - 1001-1500 байт → ожидается строка `"Medium packet"`
  - 100-1000 байт → ожидается строка `"Normal"`
  - <100 байт → ожидается строка `"Small packet"`
- **Ожидаемый результат:** Для каждого случая функция возвращает корректный индикатор.

---

## Пример запуска автотестов

```sh
cmake --build build --config Release
./build/tests/Release/unit_tests.exe --success
```

Пример вывода:
```
[doctest] test cases: 4 | 4 passed | 0 failed | 0 skipped
[doctest] assertions: 20 | 20 passed | 0 failed |
[doctest] Status: SUCCESS!
```

## Установка и сборка
### Требования
- Windows 10/11
- Visual Studio 2019 или новее
- CMake 3.10 или новее
- Conan 1.0 или новее
- Npcap 1.82

### Сборка проекта

1. Скачать zip-папку из 'Releases'
- [Releases](https://github.com/KJrTT/Indive_project/releases)

2. Сборка через CMake (Делается через Powershell):
```powershell
# Очистка кэша CMake
Remove-Item CMakeCache.txt
Remove-Item -Recurse -Force CMakeFiles

# Генерация проекта
cmake -B . -S ..

# Сборка
cmake --build . --config Release
```
**Будет по пути C:\Users\Name_user\indiv_project\build\Release**
### Решение проблем сборки

Если возникают проблемы при сборке:
1. Убедитесь, что все зависимости установлены
2. Проверьте версии CMake и Conan
3. Очистите кэш CMake и пересоберите проект
4. Проверьте права доступа (запуск от администратора)

## Использование

1. Запустите приложение с правами администратора
2. Выберите сетевой интерфейс для мониторинга
3. При необходимости включите ИИ-анализ
4. Нажмите "Start" для начала мониторинга

### Примечания
- Для полной функциональности требуются права администратора
- ИИ-анализ требует наличия модели `new_traffic_model.onnx`
- Рекомендуется использовать SSD для сохранения логов при интенсивном трафике
