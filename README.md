# NetworkTrafficMonitor - Мониторинг и анализ сетевого трафика

## Содержание
- [Обзор проекта](#обзор-проекта)
- [Текущий статус реализации](#текущий-статус-реализации)
- [Технические детали](#технические-детали)
- [Использование](#использование)
- [Тестирование (Ручное)](#Ручное-тестирование)
- [Тестирование (Автотесты через doctest)](#Автоматические-тесты)
- [Установка и сборка](#Установка-и-сборка)
## Обзор проекта

NetworkTrafficMonitor - это приложение для мониторинга состояния локальной сети, разработанное на C++. Оно предоставляет инструменты для обнаружения подключенных устройств, анализа сетевого трафика и выявления потенциальных угроз с использованием технологий искусственного интеллекта.

### Основные возможности
- Сканирование сети и обнаружение активных устройств
- Отображение списка устройств с их параметрами (IP, MAC, статус, задержка)
- Проверка доступности устройств (Ping)
- Логирование событий (подключение/отключение устройств)
- Анализ сетевого трафика в реальном времени
- Сохранение данных в SQLite или CSV
- ИИ-анализ трафика для обнаружения аномалий

## Текущий статус реализации

### Реализовано ✅
1. **Захват сетевого трафика**
   - Интеграция с Npcap/PcapPlusPlus
   - Поддержка различных сетевых интерфейсов
   - Фильтрация пакетов

2. **Пользовательский интерфейс**
   - Отображение списка сетевых интерфейсов
   - Таблица пакетов с детальной информацией
   - Статистика по протоколам
   - Фильтрация и поиск
   - Цветовая индикация протоколов

3. **Логирование**
   - Сохранение в SQLite
   - Экспорт в CSV
   - Асинхронное логирование

4. **Базовый ИИ-анализ**
   - Интеграция с ONNX Runtime
   - Базовая модель анализа трафика
   - Отдельная панель для подозрительного трафика

## Технические детали

### Используемые технологии

1. **C++17**
   - Выбор обусловлен производительностью и низкоуровневым контролем
   - Прямой доступ к сетевым операциям
   - Минимальные накладные расходы
   - Потенциальная кроссплатформенность

2. **wxWidgets**
   - Кроссплатформенный GUI-фреймворк
   - Поддержка тем и стилизации
   - Богатый набор готовых виджетов
   - Меньший размер дистрибутива по сравнению с Qt

3. **Npcap + PcapPlusPlus**
   - Npcap: современный драйвер для Windows 10/11
   - PcapPlusPlus: C++ обертка с удобным API
   - Поддержка многопоточности
   - Расширенные возможности фильтрации

4. **Система сборки**
   - CMake для кроссплатформенной сборки
   - Conan для управления зависимостями
   - Поддержка различных конфигураций сборки

5. **Оптимизация производительности**
   - Буферизация данных для снижения нагрузки
   - Асинхронное логирование
   - Оптимизация обновлений UI
   - 
## Ручное_тестирование
Ручное тестирование необходимо для проверки пользовательского интерфейса, интеграции и сценариев, которые сложно покрыть автотестами.
### 1. Проверка запуска и интерфейса
- **Шаги:**
  1. Запусткаем приложение `NetworkTrafficMonitor.exe`.
  2. Окно открывается, все элементы управления (кнопки, списки, поля ввода) отображаются корректно.
  3. Проверяем, что интерфейс не "заморожен" и реагирует на действия пользователя.
- **Ожидаемый результат:** Приложение запускается, интерфейс работает корректно.

### 2. Тестирование захвата трафика
- **Шаги:**
  1. Выбераем сетевой интерфейс из списка.
  2. Нажмимаем кнопку "Start" для начала захвата.
  3. Пакеты начинают отображаться в таблице, информация обновляется в реальном времени.
  4. Останавливаем захват кнопкой "Stop" — поток пакетов должен прекратиться.
  5. Повторно запускаем захват, убеждаемся, что приложение корректно работает после остановки.
- **Ожидаемый результат:** Пакеты отображаются, захват можно запускать и останавливать многократно.

### 3. Проверка фильтрации и поиска
- **Шаги:**
  1. Вводим фильтр по протоколу (например, `TCP`, `UDP`, `DNS`) или IP-адресу.
  2. Смотрим, что отображаются только соответствующие пакеты.
  3. Очищаем фильтр — должны отображаться все пакеты.
- **Ожидаемый результат:** Фильтрация работает корректно.

### 4. Проверка AI-анализа
- **Шаги:**
  1. Включаем опцию AI-анализа (если доступна).
  2. Проверяем, что анализ работает, результаты отображаются в отдельной таблице/гриде.
  3. Проверяем, что при отключении AI-анализа результаты скрываются.
- **Ожидаемый результат:** AI-анализ работает, результаты корректно отображаются и скрываются.

### 5. Проверка логирования
- **Шаги:**
  1. Включаем логирование в файл (выберите путь для сохранения).
  2. Проверяяем, что файл создаётся и содержит корректные записи о трафике.
  3. Откройте файл в текстовом редакторе и посмотрите, что структура и данные соответствуют ожидаемым.
- **Ожидаемый результат:** Лог-файл создаётся и содержит корректные данные.

### 6. Проверка обработки ошибок
- **Шаги:**
  1. Отключаем сетевой интерфейс и пробуем начать захват — приложение должно корректно обработать ошибку (например, показать сообщение).
  2. Попробуем начать захват без выбора интерфейса — приложение должно предупредить пользователя.
- **Ожидаемый результат:** Ошибки корректно обрабатываются.
  
### 7. Проверка стабильности и производительности
- **Шаги:**
  1. Оставляем захват трафика включённым на длительное время (10-30 минут).
  2. Смотрим , что приложение не "утекает" по памяти, не зависает и не падает.
- **Ожидаемый результат:** Приложение стабильно работает длительное время.

### 8. Проверка работы с несколькими окнами
- **Шаги:**
  1. Открываем несколько экземпляров приложения (если поддерживается).
  2. Каждый экземпляр работает независимо и корректно.
- **Ожидаемый результат:** Несколько окон работают параллельно без конфликтов.

### 9. Проверка корректного завершения работы
- **Шаги:**
  1. Завершаем работу приложения через меню или кнопку "Закрыть".
  2. Все ресурсы освобождаются, логи корректно закрываются, приложение не остаётся в процессах.
- **Ожидаемый результат:** Приложение корректно завершает работу, не оставляя "висячих" процессов.

## Автоматические тесты

В проекте реализованы автотесты с помощью библиотеки [doctest](https://github.com/doctest/doctest). Все тесты находятся в файле [`tests/unit_tests.cpp`](./tests/unit_tests.cpp).

### Описание автотестов

#### 1. ProtocolNameFromPacket - TCP variants
- **Назначение:** Проверяет определение протокола для TCP-пакетов.
- **Входные данные:** Искусственно созданные TCP-пакеты с разными портами.
- **Проверки:**
  - HTTP (порт 80) → ожидается строка `"HTTP"`
  - HTTPS (порт 443) → ожидается строка `"HTTPS"`
  - Прочие TCP (порт 1234) → ожидается строка `"TCP"`
- **Ожидаемый результат:** Для каждого случая функция возвращает корректное имя протокола.

#### 2. ProtocolNameFromPacket - UDP variants
- **Назначение:** Проверяет определение протокола для UDP-пакетов.
- **Входные данные:** Искусственно созданные UDP-пакеты с разными портами.
- **Проверки:**
  - DNS (порт 53) → ожидается строка `"DNS"`
  - Прочие UDP (порт 1234) → ожидается строка `"UDP"`
- **Ожидаемый результат:** Для каждого случая функция возвращает корректное имя протокола.

#### 3. ProtocolNameFromPacket - ARP, ICMP, IPv4, IPv6
- **Назначение:** Проверяет определение протокола для специальных и fallback-пакетов.
- **Входные данные:** Искусственно созданные пакеты ARP, ICMP, IPv4 (без TCP/UDP/ICMP), IPv6.
- **Проверки:**
  - ARP → ожидается строка `"ARP"`
  - ICMP → ожидается строка `"ICMP"`
  - IPv4 (fallback) → ожидается строка `"IPv4"`
  - IPv6 (fallback) → ожидается строка `"IPv6"`
- **Ожидаемый результат:** Для каждого случая функция возвращает корректное имя протокола.

#### 4. GetLengthIndicator - all categories
- **Назначение:** Проверяет функцию-индикатор размера пакета.
- **Входные данные:** Различные значения длины пакета.
- **Проверки:**
  - >1500 байт → ожидается строка `"Large packet"`
  - 1001-1500 байт → ожидается строка `"Medium packet"`
  - 100-1000 байт → ожидается строка `"Normal"`
  - <100 байт → ожидается строка `"Small packet"`
- **Ожидаемый результат:** Для каждого случая функция возвращает корректный индикатор.

---

## Пример запуска автотестов

```sh
cmake --build build --config Release
./build/tests/Release/unit_tests.exe --success
```

Пример вывода:
```
[doctest] test cases: 4 | 4 passed | 0 failed | 0 skipped
[doctest] assertions: 20 | 20 passed | 0 failed |
[doctest] Status: SUCCESS!
```
![UnitTest](https://github.com/user-attachments/assets/b8e8a113-0395-4d83-ab58-1512c4294348)


## Установка и сборка
### Требования
- Windows 10/11
- Visual Studio 2019 или новее
- CMake 3.10 или новее
- Conan 1.0 или новее
- Npcap 1.82

### Сборка проекта

1. Скачать zip-папку из 'Releases'
- [Releases](https://github.com/KJrTT/Indive_project/releases)

2. Сборка через CMake (Делается через Powershell):
```powershell
# Очистка кэша CMake
Remove-Item CMakeCache.txt
Remove-Item -Recurse -Force CMakeFiles

# Генерация проекта
cmake -B . -S ..

# Сборка
cmake --build . --config Release
```
**Будет по пути C:\Users\Name_user\indiv_project\build\Release**
### Решение проблем сборки

Если возникают проблемы при сборке:
1. Убедитесь, что все зависимости установлены
2. Проверьте версии CMake и Conan
3. Очистите кэш CMake и пересоберите проект
4. Проверьте права доступа (запуск от администратора)

## Использование

1. Запустите приложение с правами администратора
2. Выберите сетевой интерфейс для мониторинга
3. При необходимости включите ИИ-анализ
4. Нажмите "Start" для начала мониторинга

### Примечания
- Для полной функциональности требуются права администратора
- ИИ-анализ требует наличия модели `new_traffic_model.onnx`
- Рекомендуется использовать SSD для сохранения логов при интенсивном трафике
